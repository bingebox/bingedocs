# 解读云原生应用15要素
    Heroku的创始人Adam Wiggins于2012年发布了“The Twelve-Factor APP”，即云原生应用十二要素。  
    之后，同样作为云计算领导者，Pivotal重新整理了Beyond the 12 factor App, 即云原生15要素。

1. One Codebase, One Application  
   Heroku: 一份基准代码，多份部署.  

   解读：  
    * 一个应用, 一份基准代码。  
    * 分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。  
    * 多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用依赖管理策略去加载它们。  
    * 代码要进行版本管理。  
    * 一份基准代码可以是一个代码仓库，也可以一组代码仓库。  

   工具：  
    * git和svn 
    * GitLab、GitHub
   
2. API First  
   Heroku：无.  

   解读：  
    * 基于API来在系统的不同层次进行解耦；  
    * 前后端分离，前后端通过API来交互，通常是基于HTTP(S) 的REST API，数据格式一般为JSON；  
    * 系统的服务之间也通过API来交互，通常是基于TCP的RPC调用； 
    * 服务内部不同层级也通过API来交互，通常是代码级别的方法或函数调用；  

   工具：  
    * API测试工具（Postman，SwaggerUI等）、API性能测试工具（JMeter等）、API文档管理（Yapi等）。

3. Dependency Management  
   Heroku：显式声明依赖关系.  

   解读：    
   * 不要隐式依赖系统级的类库。  
   * 通过依赖清单，确切地声明所有依赖项。  
   * 在运行过程中通过依赖隔离工具来确保程序不会调用系统中存在但清单中未声明的依赖项。  
   * 一个构建好的二进制程序包应该包含它所需要的全部依赖，可以独立运行。比如一个包含了全部依赖的Spring Boot的all-in-one的可独立运行的jar包，又比如一个包含了全部依赖可独立运行的Docker镜像。   

   工具：  
   * 使用依赖管理工具, 比如Maven、Gradle、npm。  
   * 使用制品仓库，比如Nexus、Harbor。  

   微服务间依赖原则:
   * 按用途从上到下将服务划分为组合服务、业务服务和基础服务，上层服务可以依赖下层服务，下层服务不可以依赖上层服务.
   * 组合服务和业务服务都可以对外提供服务，基础服务不能对外提供服务.
   * 业务服务之间可以相互依赖，但是不能存在“循环依赖”（A依赖于B，B又依赖于A），出现“循环依赖”时由组合服务进行服务组合（组合服务C依赖于服务A，同时C还依赖于B）.

4. Design, Build, Release, Run  
   Heroku: 严格分离构建和运行.   

   解读：  
    * 采用持续集成（CI）和持续交付（CD）实践；
    * 采用CI/CD Pipeline来自动化构建、自动化测试和自动化部署；  

   工具:   
    * CI: Jenkins、GitLab-CI、Drone.
    * 自动化部署：Ansible.

5. Configuration, Credentials and Code  
   Heroku: 在环境中存储配置.

   解读：  
    * 代码和配置分离；  
    * 在不同环境使用不同的配置；  
    * 妥善保管凭证信息，不允许将凭证信息保存到代码中；  
    * 使用服务配置中心来管理配置。  

   工具:  
    * 使用服务配置中心来管理配置, 如Consul, Etcd, Nacos, Appolo等。  

   当前有两个做法:   
    * 应用程序读取配置文件yml，yml放在配置中心，由remco工具来实时更新，重启应用程序，每个部署有自己独立的yml配置文件。
    * 应用程序读取环境变量，由docker compose文件注入，每个部署有自己的环境变量定义文件。  

6. Logs  
   Heroku：把日志当作事件流.  

   解读：
    * 日志直接输出到标准输出（stdout或stderr），而不是写入到日志文件；  
    * 由统一的日志采集系统来存储、分析和处理日志；  

   工具：ELK或EFK。  

7. Disposability   
   Heroku：快速启动和优雅终止可最大化健壮性

   解读：
    * 服务需要可以被快速启动和快速终止；
    * 这就要求服务要足够小，启动过程要足够简单；
    * 把服务打包成一个独立的单元（比如容器）来部署。  

   工具：容器技术，比如Spring Boot自带了Web容器，Docker容器等。

8. 后端服务（Backing Services）    
   Heroku：把后端服务当作附加资源

   解读：
    * 把后端用到的中间件和资源都当成服务，而不是实体，比如：
    * 数据库服务：可能是MySQL数据库服务实例，或者其它关系型数据库服务实例
    * 缓存服务：可能是Redis服务实例；
    * 消息队列服务：可能是Kafka服务实例；
    * 对象存储服务：可能是阿里云的OSS对象存储，也可能是AWS的S3, 以及MinIO；
    * 邮件服务：可能是Mailgun的SMTP服务；
    * 认证授权服务：可能是第三方的OAuth认证授权服务；

9. 环境一致性（Environment Parity)  
   Heroku：尽可能的保持开发，预发布，线上环境相同

   解读：
    * 保持开发、测试、预发布和生产环境的部署架构、程序版本和时钟一致；
    * 基础设施即代码（Infrastructure as Code）

   工具：
    * 虚拟化管理平台，比如VMSphere； 
    * 基础架构管理工具，比如Terraform。

10. 管理进程（Adminstrative Process）  
    Heroku：后台管理任务当作一次性进程运行

    解读：
    * 区分一次性任务和常规任务；
    * 常规任务可以作成定时任务。

    工具：任务调度工具，比如Spring Quartz, Azkaban, Oozie。

11. 端口绑定（Port Binding）   
    Heroku：通过端口绑定提供服务

    解读：
    * 服务启动时动态绑定随机端口，不写死服务的端口；
    * 通过动态路由来实现服务寻址。

    工具：微服务的服务注册中心、Kubernetes的服务路由。

12. 无状态进程（Stateless Processes)  
    Heroku：以一个或多个无状态进程运行应用

    解读：
    * 服务本身是无状态的，但是应用是有状态的；
    * 应用的状态存储在文件存储服务、数据库存储服务、缓存服务和消息队列服务中；
    * 无状态服务易于横向扩展。
    * 一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。

13. 并发（Concurrency)   
    Heroku：通过进程模型进行扩展。

    解读：
    * 横向扩展（简单地增加服务实例和计算节点）就可以提升系统的并发处理能力。

14. 遥测（Telemetry)   
    Heroku：无

    解读：
    * 容器云和服务的监控和告警；
    * 服务健康检查（探针）；
    * 服务调用链路跟踪；
    * 服务故障隔离（熔断）、服务降级（限流）和故障自动恢复。

    工具：
    * 监控，比如Prometheus、Grafana；
    * 微服务框架提供的服务熔断、限流和链路跟踪工具。

15. 认证和鉴权（Authentication and Authorization）  
    Heroku：无

    解读：
    * 系统的认证和鉴权；
    * 保证系统安全性，防止未授权访问，防止水平越权；
    * RBAC权限控制模型。

    工具：
    * OAuth2，OpenID，SSO（单点登录）；
    * Java生态中的Spring Security、Shiro。
